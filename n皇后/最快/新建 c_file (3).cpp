#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// N Queens Problem
// 试探-回溯算法，递归实现

// sum用来记录皇后放置成功的不同布局数；upperlim用来标记所有列都已经放置好了皇后。
long sum = 0, upperlim = 1;      

// 试探算法从最右边的列开始。
void test(long row, long ld, long rd) 。
{
   if (row != upperlim)
   {
  // row，ld，rd进行“或”运算，求得所有可以放置皇后的列,对应位为0，
          // 然后再取反后“与”上全1的数，来求得当前所有可以放置皇后的位置，对应列改为1。
          // 也就是求取当前哪些列可以放置皇后。
  long pos = upperlim & ~(row | ld | rd); 
  while (pos) // 0 -- 皇后没有地方可放，回溯。
  {
 // 拷贝pos最右边为1的bit，其余bit置0。
 // 也就是取得可以放皇后的最右边的列。
 long p = pos & -pos;                                               

 // 将pos最右边为1的bit清零。
                 // 也就是为获取下一次的最右可用列使用做准备，
                 // 程序将来会回溯到这个位置继续试探。
 pos -= p;                            

 // row + p，将当前列置1，表示记录这次皇后放置的列。
 // (ld + p) << 1，标记当前皇后左边相邻的列不允许下一个皇后放置。
 // (ld + p) >> 1，标记当前皇后右边相邻的列不允许下一个皇后放置。
                 // 此处的移位操作实际上是记录对角线上的限制，只是因为问题都化归
                 // 到一行网格上来解决，所以表示为列的限制就可以了。显然，随着移位
                 // 在每次选择列之前进行，原来N×N网格中某个已放置的皇后针对其对角线
                 // 上产生的限制都被记录下来了。 
 test(row + p, (ld + p) << 1, (rd + p) >> 1);                              
  }
   } 
   else    
   {
 // row的所有位都为1，即找到了一个成功的布局，回溯。
  sum++;
   }
}

int main(int argc, char *argv[])
{
   time_t tm;
   int n = 16;

   if (argc != 1)
  n = atoi(argv[1]);
   tm = time(0);

   // 因为整型数的限制，最大只能32位，
   // 如果想处理N大于32的皇后问题，需要
   // 用bitset数据结构进行存储。
   if ((n < 1) || (n > 32))                  
   {
  printf(" 只能计算1-32之间\n");
  exit(-1);
   }
   printf("%d 皇后\n", n);

   // N个皇后只需N位存储，N列中某列有皇后则对应bit置1。
   upperlim = (upperlim << n) - 1;          

   test(0, 0, 0);
   printf("共有%ld种排列, 计算时间%d秒 \n", sum, (int) (time(0) - tm));
}

上述代码容易看懂，但我觉得核心的是在针对试探－回溯算法所用的数据结构的设计上。
程序采用了递归，也就是借用了编译系统提供的自动回溯功能。

算法的核心：使用bit数组来代替以前由int或者bool数组来存储当前格子被占用或者说可用信息，从这

可以看出N个皇后对应需要N位表示。
巧妙之处在于：以前我们需要在一个N*N正方形的网格中挪动皇后来进行试探回溯，每走一步都要观察

和记录一个格子前后左右对角线上格子的信息；采用bit位进行信息存储的话，就可以只在一行格子也

就是（1行×N列）个格子中进行试探回溯即可，对角线上的限制被化归为列上的限制。
程序中主要需要下面三个bit数组，每位对应网格的一列，在C中就是取一个整形数的某部分连续位即可

。
row用来记录当前哪些列上的位置不可用，也就是哪些列被皇后占用，对应为1。
ld，rd同样也是记录当前哪些列位置不可用，但是不表示被皇后占用，而是表示会被已有皇后在对角线

上吃掉的位置。这三个位数组进行“或”操作后就是表示当前还有哪些位置可以放置新的皇后，对应0

的位置可放新的皇后。如下图所示的8皇后问题求解得第一步：
row:        [ ][ ][ ][ ][ ][ ][ ][*]
ld:         [ ][ ][ ][ ][ ][ ][*][ ]
rd:         [ ][ ][ ][ ][ ][ ][ ][ ]
------------------------------------
row|ld|rd:  [ ][ ][ ][ ][ ][ ][*][*]
所有下一个位置的试探过程都是通过位操作来实现的